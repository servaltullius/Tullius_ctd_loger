가능합니다. “로그만 보고 추측”하는 크래시로거의 한계를 넘으려면, **게임 내부에서 ‘직전 상태(블랙박스)’를 매우 저비용으로 기록**하고, **외부(별도 프로세스)에서 프리징/크래시를 감지해 WCT(Wait Chain Traversal) + 미니덤프 + 블랙박스 스트림을 묶어서** 남기는 구조가 가장 현실적이고 정확도가 높습니다.

아래는 **바로 구현 시작 가능한 수준의 개발 설계서(폴더/빌드/모듈/인터페이스/에러처리/로그포맷/코드 골격 포함)** 입니다.
(참고로 CommonLibSSE NG 기반이면 SE/AE/GOG/VR을 단일 DLL로 커버하는 방향도 가능하지만, 훅/Relocation ID는 결국 버전별로 정확히 맞춰야 합니다. ([GitHub][1]))

---

## 1) 목표와 핵심 아이디어

### 1.1 목표

* **크래시(예외) 시점**: “어떤 모드가 문제 같음” 수준이 아니라

  * *예외 코드/주소/스레드*,
  * *직전 수 초~수 분의 게임 상태 이벤트(블랙박스)*,
  * *미니덤프(호출스택/모듈/스레드/핸들 등)*
    를 한 번에 확보.
* **프리징(무응답/교착/무한대기) 시점**: 로그가 안 남는 경우가 많으니

  * *“현재 어떤 스레드가 무엇을 기다리는지(WCT wait chain)”* +
  * *“그 직전 블랙박스”* +
  * *“행(hang) 덤프”*
    를 남겨 원인 후보를 좁힘.

### 1.2 전체 아키텍처 (3 컴포넌트)

1. **SKSE 플러그인(DLL)**

   * 게임 내부에서 저비용으로 “블랙박스 이벤트 링버퍼” 기록
   * 메인스레드 heartbeat 갱신(프리징 탐지 기준)
   * 크래시(예외) 발생 시 최소 정보만 공유메모리에 저장하고 이벤트 신호

2. **외부 Watchdog/Collector(EXE)**

   * 공유메모리/이벤트 오브젝트로 상태 감시
   * 프리징 탐지 시 **WCT 캡처** + **미니덤프 생성** + (선택) 블랙박스/요약을 user stream으로 덤프에 삽입
   * 크래시 신호 시 **크래시 덤프** 생성
   * *MiniDumpWriteDump는 가능한 별도 프로세스에서 호출 권장* (타겟 프로세스 불안정/로더 데드락 위험) ([Microsoft Learn][2])

3. **Analyzer(옵션: EXE/GUI)**

   * 덤프 + user stream(블랙박스/WCT)을 읽어 “원인 후보 리포트” 생성
   * DbgHelp 심볼해석/스택워킹(단, DbgHelp는 단일 스레드/동기화 필요) ([Microsoft Learn][3])

---

## 2) 레포/빌드 구조 (CMake + vcpkg 권장)

### 2.1 폴더 트리

```
SkyrimDiag/
  CMakeLists.txt
  vcpkg.json
  vcpkg-configuration.json
  cmake/
    toolchain.cmake
  shared/
    SkyrimDiagShared.h
    SkyrimDiagProtocol.h
    JsonWriter.h
  plugin/
    CMakeLists.txt
    src/
      PluginMain.cpp
      SharedMemory.cpp
      Blackbox.cpp
      HeartbeatHook.cpp
      EventSinks.cpp
      CrashHandler.cpp
    include/
      PluginAPI.h
  helper/
    CMakeLists.txt
    src/
      main.cpp
      ProcAttach.cpp
      HangDetect.cpp
      WctCapture.cpp
      MiniDump.cpp
      UserStreams.cpp
      Logger.cpp
    include/
      HelperAPI.h
  analyzer/   (선택)
    CMakeLists.txt
    src/
      main.cpp
      DumpReader.cpp
      Symbolizer.cpp
      Report.cpp
  dist/
    SkyrimDiag.ini
    README.md
```

### 2.2 템플릿/환경변수 방식

* CommonLibSSE NG 템플릿들은 보통 CMake + vcpkg 기반이며, 빌드 후 dll/pdb를 Skyrim Data나 MO2/Vortex mods 폴더로 자동 복사하도록 환경변수를 씁니다(예: `SKYRIM_FOLDER`, `SKYRIM_MODS_FOLDER`). ([GitHub][4])
* 다른 템플릿은 `local.cmake`로 POST_BUILD 복사를 구성하는 방식도 제공합니다. ([GitHub][5])

---

## 3) 공통 데이터 계약(Shared Memory + Event)

프리징/크래시 상황에서 **절대 “동적 할당/락/파일 I/O/심볼해석”**을 플러그인 쪽에서 하지 않는 게 중요합니다.
플러그인은 **공유메모리 링버퍼 + 이벤트 신호**까지만.

### 3.1 네이밍 규칙(커널 오브젝트)

* PID 기반으로 충돌 방지:

  * `Local\SkyrimDiag_{PID}_SHM`
  * `Local\SkyrimDiag_{PID}_CRASH`
  * `Local\SkyrimDiag_{PID}_QUIT` (선택)

### 3.2 공유메모리 레이아웃 (MVP)

`shared/SkyrimDiagShared.h` (골격)

```cpp
#pragma once
#include <Windows.h>
#include <cstdint>
#include <type_traits>

namespace skydiag {

// ---- constants ----
static constexpr uint32_t kMagic = 0x53444941; // 'SDIA'
static constexpr uint32_t kVersion = 1;
static constexpr uint32_t kEventCapacity = 1u << 16; // 65536

enum class EventType : uint16_t {
  kInvalid = 0,
  kSessionStart = 1,
  kHeartbeat    = 2,
  kMenuOpen     = 10,
  kMenuClose    = 11,
  kLoadStart    = 20,
  kLoadEnd      = 21,
  kCellChange   = 30,
  kNote         = 40,
  kCrash        = 100,
  kHangMark     = 200,
};

enum StateFlags : uint32_t {
  kState_None        = 0,
  kState_Frozen      = 1u << 0, // stop writing blackbox after crash mark
  kState_Loading     = 1u << 1, // optional
  kState_InMenu      = 1u << 2, // optional
};

struct EventPayload {
  uint64_t a = 0;
  uint64_t b = 0;
  uint64_t c = 0;
  uint64_t d = 0;
};

// Seqlock-style: seq odd=writing, even=committed
struct BlackboxEvent {
  volatile uint32_t seq;   // writer increments, sets odd->even
  uint32_t tid;
  uint64_t qpc;
  uint16_t type;
  uint16_t size;           // payload bytes used (<= sizeof(EventPayload))
  uint32_t reserved;
  EventPayload payload;
};

static_assert(std::is_trivially_copyable_v<BlackboxEvent>);

struct CrashInfo {
  uint32_t exception_code = 0;
  uint32_t faulting_tid   = 0;
  uint64_t exception_addr = 0;

  // Optional: copies for out-of-proc dump exception stream
  EXCEPTION_RECORD exception_record{};
  CONTEXT context{};
};

struct SharedHeader {
  uint32_t magic   = kMagic;
  uint32_t version = kVersion;
  uint32_t pid     = 0;
  uint32_t capacity = kEventCapacity;

  uint64_t qpc_freq = 0;
  uint64_t start_qpc = 0;

  volatile uint64_t last_heartbeat_qpc = 0; // updated only by main thread hook
  volatile uint32_t state_flags = 0;

  volatile uint32_t write_index = 0; // monotonically increases
  volatile uint32_t crash_seq   = 0; // increments on crash
  volatile uint32_t hang_seq    = 0; // helper can bump when it takes hang dump

  CrashInfo crash{};
};

struct SharedLayout {
  SharedHeader header;
  BlackboxEvent events[kEventCapacity];
};

} // namespace skydiag
```

### 3.3 블랙박스 이벤트 기록 규칙

* **메모리 쓰기만** 수행 (인터락/원자 연산 OK)
* 이벤트는 “최소한의 숫자 데이터”로 기록(문자열은 해시/ID로).
* reader(Helper)는 **hang/crash 시점**에만 읽어도 충분.

---

## 4) 플러그인(DLL) 상세 설계

### 4.1 책임(Plugin)

* 공유메모리 생성/초기화
* 블랙박스 Push API 제공
* 메인스레드 heartbeat 업데이트(프리징 판단 핵심)
* AddVectoredExceptionHandler로 크래시 mark + 이벤트 신호 (예외를 “먹지 않음”: `EXCEPTION_CONTINUE_SEARCH`)

> CommonLibSSE NG는 여러 런타임을 단일 DLL로 빌드하는 방향을 지원하지만, 훅/Relocation ID는 결국 맞춰야 합니다. ([GitHub][1])

### 4.2 주요 모듈과 인터페이스

#### 4.2.1 SharedMemory (plugin/src/SharedMemory.cpp)

```cpp
// PluginAPI.h
namespace skydiag::plugin {

bool InitSharedMemory();     // create file mapping + map view + events
void ShutdownSharedMemory(); // unmap/close handles

skydiag::SharedLayout* GetShared() noexcept;

HANDLE GetCrashEvent() noexcept; // named event handle
std::wstring MakeKernelName(const wchar_t* suffix);

} // namespace
```

**에러 처리 규칙**

* init 실패 시: 플러그인은 “진단 기능 비활성”으로 계속 게임 진행(크래시 유발 금지)
* SKSE 로그/파일 로그는 init 완료 후에만 (초기엔 최소화)

#### 4.2.2 Blackbox (plugin/src/Blackbox.cpp)

```cpp
namespace skydiag::plugin {

void PushEvent(skydiag::EventType type, const skydiag::EventPayload& p, uint16_t usedBytes) noexcept;

// 편의 API
inline void Note(uint64_t tag, uint64_t a=0, uint64_t b=0) noexcept;

} // namespace
```

**PushEvent 구현 골격(Seqlock)**

```cpp
#include "SkyrimDiagShared.h"
#include <Windows.h>

namespace skydiag::plugin {

static inline uint64_t QpcNow() noexcept {
  LARGE_INTEGER li{};
  QueryPerformanceCounter(&li);
  return static_cast<uint64_t>(li.QuadPart);
}

void PushEvent(skydiag::EventType type, const skydiag::EventPayload& p, uint16_t usedBytes) noexcept {
  auto* shm = GetShared();
  if (!shm) return;

  // freeze 이후에는 기록 중단
  if (shm->header.state_flags & skydiag::kState_Frozen) return;

  // index fetch-add (cross-process safe)
  const uint32_t idx = static_cast<uint32_t>(
    InterlockedIncrement(reinterpret_cast<volatile LONG*>(&shm->header.write_index)) - 1
  );

  auto& e = shm->events[idx % shm->header.capacity];
  const uint32_t seq = idx * 2; // even

  e.seq = seq | 1u; // odd => writing
  e.tid = GetCurrentThreadId();
  e.qpc = QpcNow();
  e.type = static_cast<uint16_t>(type);
  e.size = usedBytes;
  e.payload = p;
  e.seq = seq; // even => committed
}

} // namespace
```

#### 4.2.3 HeartbeatHook (plugin/src/HeartbeatHook.cpp)

핵심은 **메인 스레드에서 주기적으로 last_heartbeat_qpc 갱신**입니다.

* 구현 방법 A(권장): 메인 업데이트 루프/틱 함수에 훅(REL::RelocationID 사용)
* 구현 방법 B(차선): “매 프레임에 가까운 이벤트”에 sink 등록(입력/렌더 이벤트 등) → 정확도 떨어질 수 있음

> 여기서 훅 주소/RelocationID는 런타임별로 정확히 맞춰야 합니다. 템플릿에서도 이 점을 경고합니다. ([GitHub][6])

**인터페이스**

```cpp
namespace skydiag::plugin {
bool InstallHeartbeatHook(); // returns false if not supported
}
```

**훅 골격(의사 코드, RelocationID는 채워야 함)**

```cpp
namespace skydiag::plugin {

static void UpdateHeartbeatOnMainThread() noexcept {
  auto* shm = GetShared();
  if (!shm) return;

  LARGE_INTEGER li{};
  QueryPerformanceCounter(&li);
  shm->header.last_heartbeat_qpc = static_cast<uint64_t>(li.QuadPart);
}

struct MainUpdateHook
{
  static void thunk(/* original signature */)
  {
    UpdateHeartbeatOnMainThread();
    // optional: PushEvent(kHeartbeat, ...)
    return func(/* ... */);
  }
  static inline REL::Relocation<decltype(thunk)> func;
};

bool InstallHeartbeatHook()
{
  // TODO: REL::RelocationID / offset 세팅
  // stl::write_thunk_call<MainUpdateHook>(address);
  return true;
}

} // namespace
```

#### 4.2.4 EventSinks (plugin/src/EventSinks.cpp)

가능하면 “로딩/메뉴/세이브/셀 이동” 같은 큰 상태 변화는 sink로 기록해두면 프리징 원인 좁히기 좋습니다.

```cpp
namespace skydiag::plugin {
bool RegisterEventSinks();
}
```

예: MenuOpenClose 이벤트 기록(골격)

```cpp
class MenuSink : public RE::BSTEventSink<RE::MenuOpenCloseEvent>
{
public:
  RE::BSEventNotifyControl ProcessEvent(
    const RE::MenuOpenCloseEvent* e,
    RE::BSTEventSource<RE::MenuOpenCloseEvent>*) override
  {
    if (!e) return RE::BSEventNotifyControl::kContinue;

    skydiag::EventPayload p{};
    // p.a = Hash(menuName) 등
    if (e->opening) {
      skydiag::plugin::PushEvent(skydiag::EventType::kMenuOpen, p, sizeof(p));
    } else {
      skydiag::plugin::PushEvent(skydiag::EventType::kMenuClose, p, sizeof(p));
    }
    return RE::BSEventNotifyControl::kContinue;
  }
};
```

#### 4.2.5 CrashHandler (plugin/src/CrashHandler.cpp)

* `AddVectoredExceptionHandler` 사용
* 예외를 삼키지 않고 “표식”만 남김

```cpp
namespace skydiag::plugin {
bool InstallCrashHandler(); // AddVectoredExceptionHandler
}
```

골격:

```cpp
#include "SkyrimDiagShared.h"
#include <Windows.h>
#include <cstring>

namespace skydiag::plugin {

static LONG CALLBACK VectoredHandler(EXCEPTION_POINTERS* ep) noexcept
{
  auto* shm = GetShared();
  if (!shm || !ep || !ep->ExceptionRecord || !ep->ContextRecord)
    return EXCEPTION_CONTINUE_SEARCH;

  // 첫 크래시만 기록(중복 방지)
  const LONG prev = InterlockedCompareExchange(
    reinterpret_cast<volatile LONG*>(&shm->header.crash_seq),
    1, 0
  );
  if (prev == 0) {
    shm->header.crash.exception_code = ep->ExceptionRecord->ExceptionCode;
    shm->header.crash.exception_addr = reinterpret_cast<uint64_t>(ep->ExceptionRecord->ExceptionAddress);
    shm->header.crash.faulting_tid   = GetCurrentThreadId();

    // 복사(가능하면 try/except로 보호)
    std::memcpy(&shm->header.crash.exception_record, ep->ExceptionRecord, sizeof(EXCEPTION_RECORD));
    std::memcpy(&shm->header.crash.context, ep->ContextRecord, sizeof(CONTEXT));

    // freeze
    InterlockedOr(reinterpret_cast<volatile LONG*>(&shm->header.state_flags),
                  static_cast<LONG>(skydiag::kState_Frozen));

    if (HANDLE ev = GetCrashEvent()) {
      SetEvent(ev);
    }

    // 블랙박스에도 마킹
    skydiag::EventPayload p{};
    p.a = shm->header.crash.exception_code;
    p.b = shm->header.crash.exception_addr;
    PushEvent(skydiag::EventType::kCrash, p, sizeof(p));
  }

  return EXCEPTION_CONTINUE_SEARCH;
}

bool InstallCrashHandler()
{
  PVOID h = AddVectoredExceptionHandler(/*First=*/1, VectoredHandler);
  return h != nullptr;
}

} // namespace
```

---

## 5) Helper(EXE) 상세 설계

### 5.1 책임(Helper)

* Skyrim 프로세스 찾기/Attach
* 공유메모리 열기 + crash event 대기
* “프리징” 판단(heartbeat 기반 + 추가 신호로 보강)
* 프리징이면:

  1. WCT로 “무엇을 기다리는지/사이클인지” 캡처
  2. MiniDumpWriteDump로 덤프 생성(가능하면 out-of-proc) ([Microsoft Learn][2])
  3. 블랙박스/WCT를 minidump user stream에 포함(MINIDUMP_USER_STREAM_INFORMATION) ([Microsoft Learn][7])
* 크래시면:

  * crash mark 읽고 덤프 + user stream 작성

### 5.2 프리징 판단 로직(정확도 핵심)

* 기준: `now_qpc - last_heartbeat_qpc > threshold`
* 상태별 threshold:

  * 로딩/메뉴: 20~60초 (긴 I/O 허용)
  * 인게임: 5~10초
* (옵션) 보강: 윈도우 응답성 체크(SendMessageTimeout) / FPS 드랍 등

### 5.3 WCT 캡처 모듈 (helper/src/WctCapture.cpp)

> WCT로 wait chain을 얻으려면 `OpenThreadWaitChainSession`/`GetThreadWaitChain`을 사용합니다. ([Microsoft Learn][8])
> `GetThreadWaitChain`은 권한/버퍼 부족/사이클 여부 등 반환 조건이 명확히 문서화되어 있습니다. 또한 wait chain 정보는 호출 시점 기준 동적이라 이후엔 바뀔 수 있습니다. ([Microsoft Learn][9])

#### 5.3.1 인터페이스

```cpp
namespace skydiag::helper {

struct WctNode {
  uint32_t objectType;
  uint32_t objectStatus;
  uint64_t objectId; // best-effort
  uint32_t owningThreadId;
};

struct WctThreadReport {
  uint32_t tid;
  bool isCycle;
  std::vector<WctNode> nodes;
};

struct WctReport {
  uint32_t pid;
  uint64_t timestampUnixMs;
  std::vector<WctThreadReport> threads;
};

bool EnableDebugPrivilege(); // SE_DEBUG_NAME
bool CaptureWct(uint32_t pid, WctReport& out, std::wstring* err);

} // namespace
```

#### 5.3.2 EnableDebugPrivilege 골격

Using WCT 예제에서도 SE_DEBUG_NAME 권한 활성화를 단계로 포함합니다. ([Microsoft Learn][10])

```cpp
#include <Windows.h>
#include <string>

namespace skydiag::helper {

bool EnableDebugPrivilege()
{
  HANDLE token = nullptr;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token))
    return false;

  LUID luid{};
  if (!LookupPrivilegeValueW(nullptr, SE_DEBUG_NAME, &luid)) {
    CloseHandle(token);
    return false;
  }

  TOKEN_PRIVILEGES tp{};
  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  const BOOL ok = AdjustTokenPrivileges(token, FALSE, &tp, sizeof(tp), nullptr, nullptr);
  CloseHandle(token);
  return ok && GetLastError() == ERROR_SUCCESS;
}

} // namespace
```

#### 5.3.3 CaptureWct 골격

```cpp
#include <Windows.h>
#include <wct.h>
#include <tlhelp32.h>
#include <vector>

#pragma comment(lib, "Advapi32.lib")

namespace skydiag::helper {

static std::vector<DWORD> EnumerateThreads(DWORD pid)
{
  std::vector<DWORD> tids;
  HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  if (snap == INVALID_HANDLE_VALUE) return tids;

  THREADENTRY32 te{ sizeof(te) };
  for (BOOL ok = Thread32First(snap, &te); ok; ok = Thread32Next(snap, &te)) {
    if (te.th32OwnerProcessID == pid) tids.push_back(te.th32ThreadID);
  }
  CloseHandle(snap);
  return tids;
}

bool CaptureWct(uint32_t pid, WctReport& out, std::wstring* err)
{
  out.pid = pid;
  out.threads.clear();

  // 권한 (실패해도 일부는 될 수 있으니 정책적으로 선택)
  EnableDebugPrivilege();

  HWCT hWct = OpenThreadWaitChainSession(0, nullptr);
  if (!hWct) {
    if (err) *err = L"OpenThreadWaitChainSession failed: " + std::to_wstring(GetLastError());
    return false;
  }

  for (DWORD tid : EnumerateThreads(pid)) {
    WAITCHAIN_NODE_INFO nodes[WCT_MAX_NODE_COUNT]{};
    DWORD nodeCount = WCT_MAX_NODE_COUNT;
    BOOL isCycle = FALSE;

    // WCTP_GETINFO_ALL_FLAGS: 가능한 많은 정보 요청
    BOOL ok = GetThreadWaitChain(
      hWct, nullptr, WCTP_GETINFO_ALL_FLAGS,
      tid, &nodeCount, nodes, &isCycle
    );

    // 실패하더라도 ERROR_MORE_DATA 등은 부분 결과가 유효할 수 있음 :contentReference[oaicite:12]{index=12}
    DWORD gle = ok ? 0 : GetLastError();

    WctThreadReport tr{};
    tr.tid = tid;
    tr.isCycle = isCycle ? true : false;

    const DWORD n = (nodeCount > WCT_MAX_NODE_COUNT) ? WCT_MAX_NODE_COUNT : nodeCount;
    tr.nodes.reserve(n);

    for (DWORD i = 0; i < n; ++i) {
      WctNode nn{};
      nn.objectType = nodes[i].ObjectType;
      nn.objectStatus = nodes[i].ObjectStatus;
      nn.owningThreadId = nodes[i].ThreadObject.ThreadId; // when applicable
      // objectId best-effort (union varies by type)
      tr.nodes.push_back(nn);
    }

    out.threads.push_back(std::move(tr));

    (void)gle; // 필요시 로깅
  }

  CloseThreadWaitChainSession(hWct);
  return true;
}

} // namespace
```

---

## 6) MiniDump 생성 + User Stream 포함(가장 중요한 코드 골격)

### 6.1 왜 Helper(별도 프로세스)에서 덤프를 뜨나?

Microsoft 문서에서 **MiniDumpWriteDump는 가능하면 “타겟 프로세스 외부(별도 프로세스)”에서 호출**하라고 권장합니다. 크래시 직후 타겟이 불안정하면 로더 데드락 등 부작용이 있을 수 있다고 명시합니다. ([Microsoft Learn][2])

### 6.2 MiniDumpWriteDump + MINIDUMP_USER_STREAM_INFORMATION

* `MINIDUMP_USER_STREAM_INFORMATION`은 user stream 배열을 담는 구조입니다. ([Microsoft Learn][7])
* `MINIDUMP_USER_STREAM`은 (Type, BufferSize, Buffer)로 user stream을 표현합니다. ([Microsoft Learn][11])
* stream type은 `MINIDUMP_STREAM_TYPE`을 쓰며, **`LastReservedStream(0xFFFF)`보다 큰 값은 앱 정의 스트림으로 사용 가능**합니다. ([Microsoft Learn][12])

### 6.3 Helper 모듈 인터페이스

```cpp
namespace skydiag::helper {

struct DumpOptions {
  bool fullMemory = false;
  bool includeHandleData = true;
  bool includeThreadInfo = true;
  bool includeUnloadedModules = true;
};

bool WriteDumpWithStreams(
  HANDLE hProcess,
  uint32_t pid,
  const wchar_t* dumpPath,
  const skydiag::SharedLayout* shmSnapshot,  // helper가 읽어 만든 스냅샷
  const WctReport* wct,                      // optional
  bool isCrash,
  const DumpOptions& opt,
  std::wstring* err);

} // namespace
```

### 6.4 Crash ExceptionPointers / ClientPointers 주의

* Helper(덤퍼) 프로세스에서 `EXCEPTION_POINTERS`를 **로컬 메모리에 구성**해 전달하는 경우
  `MINIDUMP_EXCEPTION_INFORMATION::ClientPointers`는 **FALSE** (로컬 주소공간) 입니다. ([Microsoft Learn][13])
  (TRUE는 예외 포인터가 “디버그 대상 프로세스(타겟) 주소공간”에 있을 때)

### 6.5 “블랙박스 + WCT JSON”을 user stream으로 넣는 골격

`helper/src/UserStreams.cpp` (핵심)

```cpp
#include "SkyrimDiagShared.h"
#include "HelperAPI.h"
#include <Windows.h>
#include <DbgHelp.h>
#include <vector>
#include <string>

#pragma comment(lib, "Dbghelp.lib")

namespace skydiag::helper {

// 앱 정의 stream type (0xFFFF 초과) :contentReference[oaicite:18]{index=18}
static constexpr ULONG32 kStream_Blackbox = 0x10000 + 0x5344; // arbitrary > LastReservedStream
static constexpr ULONG32 kStream_WctJson  = 0x10000 + 0x5743; // arbitrary > LastReservedStream

static std::vector<uint8_t> SerializeBlackbox(const skydiag::SharedLayout* shm)
{
  // MVP: SharedHeader + events 전체를 그대로 덤프에 담는 방식
  // (용량이 부담이면 "마지막 N개"만 잘라서 담기)
  std::vector<uint8_t> out;
  if (!shm) return out;

  const size_t bytes = sizeof(skydiag::SharedHeader) + sizeof(skydiag::BlackboxEvent) * shm->header.capacity;
  out.resize(bytes);
  std::memcpy(out.data(), &shm->header, sizeof(skydiag::SharedHeader));
  std::memcpy(out.data() + sizeof(skydiag::SharedHeader),
              shm->events,
              sizeof(skydiag::BlackboxEvent) * shm->header.capacity);
  return out;
}

static std::string SerializeWctToJsonUtf8(const WctReport& wct)
{
  // 실제로는 JSON writer로 구현(여기선 골격)
  std::string s;
  s += "{";
  s += "\"pid\":" + std::to_string(wct.pid) + ",";
  s += "\"threads\":"; s += "[]"; // TODO
  s += "}";
  return s;
}

bool WriteDumpWithStreams(
  HANDLE hProcess,
  uint32_t pid,
  const wchar_t* dumpPath,
  const skydiag::SharedLayout* shmSnapshot,
  const WctReport* wct,
  bool isCrash,
  const DumpOptions& opt,
  std::wstring* err)
{
  HANDLE hFile = CreateFileW(dumpPath, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, nullptr);
  if (hFile == INVALID_HANDLE_VALUE) {
    if (err) *err = L"CreateFileW failed: " + std::to_wstring(GetLastError());
    return false;
  }

  MINIDUMP_TYPE dumpType = MiniDumpNormal;
  if (opt.includeThreadInfo)      dumpType = (MINIDUMP_TYPE)(dumpType | MiniDumpWithThreadInfo);
  if (opt.includeHandleData)      dumpType = (MINIDUMP_TYPE)(dumpType | MiniDumpWithHandleData);
  if (opt.includeUnloadedModules) dumpType = (MINIDUMP_TYPE)(dumpType | MiniDumpWithUnloadedModules);
  if (opt.fullMemory)             dumpType = (MINIDUMP_TYPE)(dumpType | MiniDumpWithFullMemory);

  // ---- build user streams ----
  std::vector<uint8_t> blackboxBytes = SerializeBlackbox(shmSnapshot);

  std::string wctJson;
  if (wct) wctJson = SerializeWctToJsonUtf8(*wct);

  std::vector<MINIDUMP_USER_STREAM> streams;
  streams.reserve(2);

  MINIDUMP_USER_STREAM s1{};
  s1.Type = kStream_Blackbox;
  s1.BufferSize = static_cast<ULONG>(blackboxBytes.size());
  s1.Buffer = blackboxBytes.empty() ? nullptr : blackboxBytes.data();
  streams.push_back(s1);

  MINIDUMP_USER_STREAM s2{};
  if (!wctJson.empty()) {
    s2.Type = kStream_WctJson;
    s2.BufferSize = static_cast<ULONG>(wctJson.size());
    s2.Buffer = (void*)wctJson.data();
    streams.push_back(s2);
  }

  MINIDUMP_USER_STREAM_INFORMATION usi{};
  usi.UserStreamCount = static_cast<ULONG>(streams.size());
  usi.UserStreamArray = streams.empty() ? nullptr : streams.data(); // :contentReference[oaicite:19]{index=19}

  // ---- exception info (crash only) ----
  MINIDUMP_EXCEPTION_INFORMATION mei{};
  EXCEPTION_POINTERS ep{};
  EXCEPTION_RECORD er{};
  CONTEXT ctx{};

  MINIDUMP_EXCEPTION_INFORMATION* pMei = nullptr;
  if (isCrash && shmSnapshot) {
    er = shmSnapshot->header.crash.exception_record;
    ctx = shmSnapshot->header.crash.context;
    ep.ExceptionRecord = &er;
    ep.ContextRecord   = &ctx;

    mei.ThreadId = shmSnapshot->header.crash.faulting_tid;
    mei.ExceptionPointers = &ep;
    // ExceptionPointers가 로컬 주소공간이면 FALSE :contentReference[oaicite:20]{index=20}
    mei.ClientPointers = FALSE;

    pMei = &mei;
  }

  // MiniDumpWriteDump: 가능하면 별도 프로세스에서 호출 권장 :contentReference[oaicite:21]{index=21}
  BOOL ok = MiniDumpWriteDump(
    hProcess,
    pid,
    hFile,
    dumpType,
    pMei,                 // crash면 예외 포함, hang면 nullptr
    streams.empty() ? nullptr : &usi,  // user streams
    nullptr
  );

  DWORD gle = GetLastError();
  CloseHandle(hFile);

  if (!ok) {
    if (err) *err = L"MiniDumpWriteDump failed: " + std::to_wstring(gle);
    return false;
  }

  return true;
}

} // namespace skydiag::helper
```

---

## 7) Analyzer(선택) – “원인 후보”를 더 정확히

### 7.1 DbgHelp 기반 심볼/스택 해석

* StackWalk64로 스택 트레이스를 얻는 방식이 문서상 권장됩니다. ([Microsoft Learn][14])
* SymFromAddr 등 DbgHelp 함수들은 **단일 스레드**이므로 동시 호출은 **반드시 동기화**해야 합니다. ([Microsoft Learn][3])
  → Analyzer는 “단일 스레드로 처리”하거나, 글로벌 mutex로 DbgHelp 호출 보호.

### 7.2 minidump에서 스트림 읽기

* 표준 스트림은 `MiniDumpReadDumpStream`로 읽을 수 있습니다. ([Microsoft Learn][15])
* 앱 정의 stream(kStream_Blackbox 등)은

  * 1. `MiniDumpReadDumpStream`에 해당 stream number를 넣어 시도하거나(환경에 따라 동작 차이 가능)
  * 2. 덤프 헤더/디렉토리를 직접 파싱해 stream type을 찾아 읽는 방식
       을 설계에 포함시키는 게 안전합니다. (MVP는 2번 추천)

---

## 8) 로그/산출물 포맷(권장)

### 8.1 Helper가 남기는 파일

```
SkyrimDiagLogs/
  2026-01-28_21-10-33_pid1234_HANG.dmp
  2026-01-28_21-10-33_pid1234_HANG.wct.json
  2026-01-28_21-10-33_pid1234_HANG.summary.json
  SkyrimDiagHelper.log
```

### 8.2 summary.json 예시

```json
{
  "pid": 1234,
  "reason": "HANG",
  "detectedBy": "heartbeat",
  "thresholdSec": 8,
  "lastHeartbeatAgeSec": 12.4,
  "stateFlags": ["InMenu"],
  "crash": null,
  "artifacts": {
    "dump": "2026-01-28_21-10-33_pid1234_HANG.dmp",
    "wct": "2026-01-28_21-10-33_pid1234_HANG.wct.json",
    "streams": ["Blackbox", "WctJson"]
  }
}
```

---

## 9) “정확도가 올라가는 포인트” (기존 크래시로거 대비)

1. **크래시 직전 “상태 변화 블랙박스” 확보**

   * “로딩 중이었나 / 메뉴 열었나 / 셀 이동 직후였나 / 특정 UI가 열렸나” 같은 문맥이 생김
2. **프리징은 로그가 아니라 ‘스레드 대기 그래프(WCT)’로 본다**

   * deadlock/뮤텍스 대기/SendMessage 대기 등이 바로 드러날 수 있음 ([Microsoft Learn][8])
3. **덤프는 외부에서 뜬다**

   * 타겟이 불안정한 상황에서 내부 덤프는 실패/데드락 위험이 문서에 명시 ([Microsoft Learn][2])
4. (추가) Analyzer에서 “모듈/심볼”을 결합하면

   * 흔히 보는 “원인 불명” 대신 **‘대기/예외/핫스팟 함수 + 관련 모듈’**로 후보가 좁혀짐

---

## 10) Codex CLI(바이브코딩)로 구현할 때의 추천 작업 순서

1. **shared/SkyrimDiagShared.h**부터 완성(ABI/크기/정렬 고정)
2. plugin에서

   * 공유메모리 생성 + PushEvent 동작 확인(게임 실행/종료)
   * 메뉴 이벤트 하나만 기록해보고 링버퍼가 쌓이는지 확인
3. helper에서

   * PID attach + 공유메모리 읽기 + heartbeat age 출력
4. hang 감지(임계 5초) → **WCT 캡처 JSON 파일**부터 성공시키기
5. MiniDumpWriteDump(out-of-proc) 성공시키기 ([Microsoft Learn][2])
6. user stream(blackbox) 넣고 WinDbg/자체 파서로 확인 ([Microsoft Learn][7])
7. 마지막에 analyzer(심볼해석)는 천천히(DbgHelp 동기화 주의) ([Microsoft Learn][3])

---

원하시면 다음 단계로, 위 설계 그대로 **“MVP 구현 체크리스트 + 실제 CMakeLists.txt 3개(루트/plugin/helper) + main.cpp 최소 구현(attach→heartbeat→hang dump) 템플릿”**까지 한 번에 적어드릴게요.

[1]: https://github.com/CharmedBaryon/CommonLibSSE-NG?utm_source=chatgpt.com "CharmedBaryon/CommonLibSSE-NG"
[2]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump "MiniDumpWriteDump function (minidumpapiset.h) - Win32 apps | Microsoft Learn"
[3]: https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfromaddr?utm_source=chatgpt.com "SymFromAddr function (dbghelp.h) - Win32 apps"
[4]: https://github.com/SkyrimDev/HelloWorld-using-CommonLibSSE-NG "GitHub - SkyrimDev/HelloWorld-using-CommonLibSSE-NG: Simple \"Hello, world\" SKSE plugin"
[5]: https://github.com/epinter/skse-clibng-template "GitHub - epinter/skse-clibng-template: Template Project for SKSE - CommonLibSSE-NG"
[6]: https://github.com/Monitor221hz/CommonLibSSE-NG-Template-Plugin "GitHub - Monitor221hz/CommonLibSSE-NG-Template-Plugin"
[7]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream_information "MINIDUMP_USER_STREAM_INFORMATION (minidumpapiset.h) - Win32 apps | Microsoft Learn"
[8]: https://learn.microsoft.com/en-us/windows/win32/debug/wait-chain-traversal?utm_source=chatgpt.com "Wait chain traversal - Win32 apps"
[9]: https://learn.microsoft.com/en-us/windows/win32/api/wct/nf-wct-getthreadwaitchain "GetThreadWaitChain function (wct.h) - Win32 apps | Microsoft Learn"
[10]: https://learn.microsoft.com/en-us/windows/win32/debug/using-wct "Using WCT - Win32 apps | Microsoft Learn"
[11]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream "MINIDUMP_USER_STREAM (minidumpapiset.h) - Win32 apps | Microsoft Learn"
[12]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_stream_type "MINIDUMP_STREAM_TYPE (minidumpapiset.h) - Win32 apps | Microsoft Learn"
[13]: https://learn.microsoft.com/ko-kr/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_exception_information?utm_source=chatgpt.com "MINIDUMP_EXCEPTION_INFOR..."
[14]: https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-stackwalk64?utm_source=chatgpt.com "StackWalk64 function (dbghelp.h) - Win32 apps"
[15]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpreaddumpstream?utm_source=chatgpt.com "MiniDumpReadDumpStream function (minidumpapiset.h)"
