# 스카이림 크래시/프리징 “정밀 진단 모드” 개발 설계서 (초안)

* 문서 버전: v0.1
* 작성일: 2026-01-28
* 대상: Skyrim SE/AE/VR (SKSE 기반)
* 목표: “크래시 로그만으로 원인 특정이 어려운 한계”를 넘기 위해, **크래시(CTD) + 프리징/행(hang)** 을 **증거 기반으로 좁혀주는 진단 시스템**을 구축

---

## 1. 배경과 문제 정의

### 1.1 기존 크래시 로그가 가진 구조적 한계

* 대표적으로 **Crash Logger SSE AE VR**은 스택/모듈/객체 정보 등 크래시 로그를 생성하고, **모드 제작자가 배포한 PDB를 읽어 DLL CTD 디버깅을 돕는 기능**이 있습니다. ([Nexus Mods][1])
* 하지만 “로그를 봐도 원인을 특정하기 어렵다”는 문제가 흔하고(특히 **프리징/행**은 크래시 로그가 없거나 단서가 약함), **NetScriptFramework 쪽도 로그가 제공되지만 ‘진단이 여전히 까다로울 수 있다’**고 명시합니다. ([Nexus Mods][2])
* 또한 Crash Logger 쪽은 **동시에 여러 크래시 로거를 켤 수 없다**(예: NetScriptFramework 포함)라는 제한이 있어, “추가 진단”을 얹을 때 충돌 가능성을 고려해야 합니다. ([Nexus Mods][1])

### 1.2 요구되는 “정확도”의 정의

사용자가 원하는 “더 정확한 진단”을 **재현성 없이도** 높이려면, 단일 로그(스택 텍스트)만 보는 대신:

1. **사건 직전 타임라인(Blackbox)**
2. **행/데드락 구조(Wait chain)**
3. **덤프 기반(스택+모듈+메모리 스냅샷)**
4. **심볼(가능할 때)**
5. 위 1~4를 **상관분석**해서 “가능성 높은 원인 후보”를 순위화

…까지 가야 합니다.

---

## 2. 제안 솔루션 개요

### 2.1 프로젝트 명(가칭)

**SkyrimDiag** = “SKSE 진단 플러그인 + 외부 덤퍼/분석기” 묶음

### 2.2 핵심 컨셉

* **Blackbox Logging(상시 저부하 기록)**: 게임 내 주요 이벤트/상태를 고정 크기 링버퍼로 기록 (크래시/행 발생 시 직전 N초를 반드시 확보)
* **Snapshot Capture(사건 순간 스냅샷)**

  * 크래시: 예외 정보 + 미니덤프 생성
  * 프리징/행: **Wait Chain Traversal(WCT)** 로 “누가 무엇을 기다리다 멈췄는지”를 구조적으로 수집 + (가능하면) 덤프 생성
    WCT는 “행/데드락 진단”을 목적으로 하는 Windows API이며, 크리티컬 섹션/뮤텍스/SendMessage/프로세스·스레드 wait 등 다양한 동기화 프리미티브를 지원합니다. ([Microsoft Learn][3])
* **분석기(Analyzer)**: Blackbox + WCT + 덤프를 결합하여 “원인 후보”와 “근거”를 리포트로 생성

---

## 3. 아키텍처(상위 설계)

### 3.1 구성 요소

1. **SkyrimDiag.dll (SKSE 플러그인, 게임 프로세스 내부)**
2. **SkyrimDiagHelper.exe (외부 헬퍼/덤퍼, 별도 프로세스)**
3. **SkyrimDiagAnalyzer (CLI/GUI 선택, 오프라인 분석기)**

### 3.2 데이터 흐름(텍스트 다이어그램)

```
[Skyrim.exe + SkyrimDiag.dll]
  - 이벤트/상태 -> (Shared Memory RingBuffer)
  - Heartbeat  -> (Shared Memory)
  - Crash signal -> (Named Event / Named Pipe)

           |
           v

[SkyrimDiagHelper.exe]
  - Heartbeat 감시 -> Hang 판단
  - Crash signal 수신
  - (WCT로 스레드 wait chain 수집)
  - (MiniDumpWriteDump로 덤프 생성)
  - 덤프에 user stream으로 ringbuffer 삽입
           |
           v
[SkyrimDiagAnalyzer]
  - 덤프/로그/WaitChain 파싱
  - 심볼 로드(가능할 때)
  - 원인 후보 rank + 근거 리포트 생성
```

---

## 4. 기술 스택 및 근거

### 4.1 SKSE 플러그인 기반(멀티 런타임)

* **CommonLibSSE-NG**를 사용하면 SE/AE/VR을 대상으로 **단일 DLL로 멀티 런타임 대응**이 가능하고, AE의 1.6.629 전후도 단일 DLL에서 지원하도록 설계돼 있습니다. ([GitHub][4])
* SKSE 플러그인 템플릿/빌드 흐름은 skyrim.dev의 “첫 플러그인” 튜토리얼과 같은 표준 구조로 시작하는 것이 안전합니다. ([Skyrim.dev][5])

### 4.2 버전 독립 주소 처리

* **Address Library for SKSE Plugins**는 헤더+DB로 “오프셋을 버전 독립적으로” 다루는 리소스이며, SKSE DLL 플러그인을 버전 독립적으로 만들기 쉽게 한다고 명시합니다. ([Nexus Mods][6])
* 또한 해당 페이지에는 “CommonLib을 쓰면 이미 내장돼 있어 별도로 필요 없을 수 있다”는 실무적 안내도 존재합니다. ([Nexus Mods][6])

### 4.3 프리징/행 분석: Wait Chain Traversal(WCT)

* WCT는 **행/데드락 진단**을 목표로 하고, `OpenThreadWaitChainSession` + `GetThreadWaitChain`으로 특정 스레드의 wait chain을 가져옵니다. ([Microsoft Learn][3])
* Microsoft 예제(Using WCT)도 “시스템 스레드를 열거하고 wait chain을 출력”하는 흐름을 보여줍니다. ([Microsoft Learn][7])

### 4.4 덤프 생성: MiniDumpWriteDump (외부 프로세스 권장)

* Microsoft 문서에 따르면 `MiniDumpWriteDump`는 가능하면 **덤프 대상 프로세스 ‘외부’에서 호출**하는 것이 권장되며, 특히 이미 크래시한 불안정 상태에서 내부 호출 시 **loader deadlock** 같은 부작용이 있을 수 있다고 경고합니다. ([Microsoft Learn][8])
* 또한 DbgHelp 계열은 **단일 스레드만 안전**하므로, 동시 호출은 동기화가 필요합니다. (`MiniDumpWriteDump`, `StackWalk64`, `SymFromAddr` 등) ([Microsoft Learn][8])

### 4.5 덤프에 “Blackbox”를 같이 넣기: User Stream

* `MINIDUMP_USER_STREAM_INFORMATION` / `MINIDUMP_USER_STREAM`를 이용하면 **사용자 정의 데이터 스트림(블록)을 덤프 내부에 포함**시킬 수 있습니다. ([Microsoft Learn][9])
  → 즉, “덤프 파일 하나에 사건 직전 타임라인까지 포함”이 가능해져, 사용자 제보 품질이 크게 올라갑니다.

### 4.6 참고: ProcDump 연계 옵션(선택)

* ProcDump는 공식 문서에 옵션이 정리되어 있고, **-h(5초 이상 응답 없는 hung window), -e(처리되지 않은 예외), -ma(Full dump), -mk(커널 스택 포함)** 등이 명시돼 있습니다. ([Microsoft Learn][10])
* Microsoft의 “User-mode dump files” 문서에서도 ProcDump가 **Windows/작업관리자와 동일한 hang 정의로 hung window 모니터링**을 한다고 설명합니다. ([Microsoft Learn][11])
  다만 ProcDump는 배포/라이선스/보안 오탐 문제 가능성이 있어 “내장 덤퍼”가 기본, ProcDump는 “사용자 선택 옵션”으로 두는 걸 권장합니다.

---

## 5. 기능 요구사항

### 5.1 공통(세션 시작 시)

* 게임 버전/런타임(SE/AE/VR), SKSE 버전, 플러그인 목록(ESM/ESP/ESL), SKSE Plugins DLL 목록 기록

  * **Skyrim System Logger**가 “플러그인 리스트 덤프 / SKSE DLL 폴더 덤프 / VRAM 모니터링 / Papyrus VM heartbeat” 같은 항목을 실제로 제공하는 점은 참고하기 좋습니다. ([Nexus Mods][12])

### 5.2 Blackbox(상시)

* 이벤트를 고정 크기 링버퍼로 저장(메모리 상), 주기적으로 일부를 파일로 flush(옵션)
* 기록 이벤트(예시)

  * Cell/Worldspace 이동, 로딩 화면 진입/해제
  * 메뉴 Open/Close
  * Papyrus VM heartbeat, 스크립트 큐 지연(가능하면)
  * VRAM usage(가능하면 DXGI)
  * 최근 파일 로드(가능하면 BSResource 계층 훅)
  * 최근 호출 스택 샘플(옵션, 매우 저빈도)

### 5.3 크래시(CTD) 진단

* 목표: “어느 DLL/모듈에서 터졌는지 + 직전 타임라인 + 가능하면 심볼”
* 최소 요구 산출물

  1. Crash Snapshot JSON (예외 코드/주소/스레드 ID/컨텍스트 요약)
  2. MiniDump(.dmp)
  3. Blackbox ring buffer(덤프 user stream 또는 별도 파일)

※ 기존 Crash Logger SSE AE VR처럼 PDB가 있는 경우 더 정확해짐(모드 제작자가 PDB 배포 시). ([Nexus Mods][1])

### 5.4 프리징/행(무한로딩/정지/응답없음) 진단

* 목표: “대부분의 프리징은 결국 스레드가 무엇인가를 기다리는 상태”이므로
  **WCT 기반으로 ‘대기 사슬’을 추출**하고, deadlock cycle 여부를 판단
* 최소 요구 산출물

  1. Hang Snapshot(JSON): 마지막 heartbeat 시각, 프레임 진행 정지 여부, 현재 게임 상태(메뉴/로딩/인게임)
  2. WCT 결과(JSON): 각 스레드의 wait chain node 목록
  3. Hang Dump(.dmp) (옵션/기본 on 권장)

---

## 6. 상세 설계

## 6.1 SkyrimDiag.dll (SKSE 플러그인)

### 6.1.1 초기화 시퀀스

* `SKSEPluginLoad`에서

  * CommonLibSSE-NG 초기화
  * shared memory 생성(세션 ID 포함)
  * named event/pipe 생성(헬퍼와 핸드셰이크)
  * 이벤트 sink 등록(메뉴/로딩/세이브 등)
  * (옵션) vectored exception handler 등록
* 템플릿/빌드 구조는 skyrim.dev의 플러그인 템플릿 구조를 그대로 따르는 것을 기준으로 합니다. ([Skyrim.dev][5])

### 6.1.2 Blackbox 링버퍼(핵심)

* 목표: “크래시 직전 30~120초”를 반드시 담는다.
* 설계 포인트

  * **고정 크기**: 예) 64K 엔트리
  * **고정 크기 엔트리**: 동적 할당 최소화(크래시 상황에서 allocator가 죽을 수 있음)
  * 다중 스레드 기록 시 lock-free(원형 버퍼 + atomic index) 또는 가벼운 spinlock
* 이벤트 엔트리 구조 예시(개념)

  * timestamp(ns or us)
  * thread_id
  * event_type (enum)
  * payload (고정 크기 union / 또는 “문자열은 해시+사전”)
* 파일 flush 정책

  * 기본: 메모리 링버퍼만 유지 → 사건 시 덤프 user stream으로 포함
  * 옵션: N초마다 JSONL append(저장소 부담 증가)

### 6.1.3 Heartbeat(행 감지의 기준)

* main thread tick마다 shared memory의 heartbeat 업데이트
* 상태 플래그: {InGame, Menu, Loading, Paused, AltTab?}

  * 메뉴 open/close는 이벤트로도 기록(참고: System Logger가 메뉴 open/close 로깅 제공) ([Nexus Mods][12])

### 6.1.4 크래시 훅(최소 침습)

* 원칙: **다른 크래시 로거와 충돌 최소화**

  * Crash Logger는 “한 번에 하나만”이라는 제한을 명시합니다. ([Nexus Mods][1])
* 구현 방향

  1. **Vectored Exception Handler**에서:

     * 예외 코드/주소/스레드 ID/CONTEXT 요약을 shared memory에 기록
     * named event로 헬퍼에 “덤프 떠라” 신호
     * `EXCEPTION_CONTINUE_SEARCH`로 넘겨서 기존 로거/WER 흐름을 깨지 않음
  2. 헬퍼가 덤프를 생성(외부 프로세스 권장) ([Microsoft Learn][8])
  3. (옵션) Crash Logger 감지 시 “우리 쪽 crash dump는 끄고, 타임라인만 제공” 모드로 자동 전환

---

## 6.2 SkyrimDiagHelper.exe (외부 헬퍼/덤퍼)

### 6.2.1 역할

* Skyrim 프로세스를 감시하고,

  * **Crash signal** 수신 시 덤프 생성
  * **Hang 판단** 시 WCT + 덤프 생성
* 이유: `MiniDumpWriteDump`는 가능하면 **대상 프로세스 외부에서 호출 권장** ([Microsoft Learn][8])

### 6.2.2 Hang(프리징) 탐지 로직

* 입력: shared memory heartbeat timestamp + 상태 플래그
* 기본 규칙(예시)

  * InGame 상태에서 heartbeat가 **X초(예: 10초) 이상 갱신되지 않음**
  * Loading 상태는 threshold를 더 길게(예: 60초)
* 추가 안전장치(오탐 방지)

  * CPU 사용률이 매우 높고 디스크 I/O가 높으면 “stutter”일 수 있음 → 2차 확인
  * 옵션으로 “window message unresponsive” 체크(ProcDump -h와 같은 hung window 정의 참고 가능) ([Microsoft Learn][10])

### 6.2.3 WCT 수집

* WCT는 행/데드락 진단을 위한 API이며, 다양한 동기화 프리미티브를 지원합니다. ([Microsoft Learn][3])
* 구현 흐름(개념)

  1. 대상 프로세스의 스레드 열거
  2. `OpenThreadWaitChainSession`
  3. 각 스레드에 `GetThreadWaitChain` 호출 → `WAITCHAIN_NODE_INFO[]` 수집
     (Microsoft 예제 “Using WCT”의 흐름 참고) ([Microsoft Learn][7])
  4. 결과를 JSON으로 저장
* 핵심 산출물:

  * “Main thread가 CriticalSection을 기다리고 있고, 그 CS는 Thread B가 소유, Thread B는 SendMessage를 기다림…” 같은 **구조적 증거**

### 6.2.4 덤프 생성(MiniDumpWriteDump)

* 기본 덤프 타입 전략(개념)

  * 기본: “스택+모듈+핸들+메모리 일부” 수준(개인정보/용량 고려)
  * 옵션: Full dump(재현 어려운 문제용)
* 덤프에 Blackbox를 포함

  * `MINIDUMP_USER_STREAM_INFORMATION` / `MINIDUMP_USER_STREAM` 사용 ([Microsoft Learn][9])
  * ring buffer를 하나의 user stream으로 넣으면 “덤프 하나로 분석 가능”
* 주의: DbgHelp 계열은 single-threaded → 덤프 생성/스택워크/심볼 처리 동시 실행 금지(전역 mutex) ([Microsoft Learn][8])

---

## 6.3 SkyrimDiagAnalyzer (분석기)

### 6.3.1 입력

* `*.dmp`
* `hang_wct.json`
* `blackbox.jsonl` 또는 `dump user stream`
* `loadorder.txt`, `plugins.txt` (가능하면 자동 수집)

### 6.3.2 심볼/스택 분석

* 덤프/모듈 주소를 함수명으로 해석하려면 DbgHelp의 심볼 핸들러를 사용:

  * 예: `SymFromAddr`는 주소에 대한 심볼 정보를 가져오며, 사용 전 `SymInitialize`로 초기화 필요. ([Microsoft Learn][13])
* 스택워킹은 `StackWalk64`를 사용하며, 이 또한 DbgHelp 단일 스레드 제약이 있습니다. ([Microsoft Learn][14])
* 모드 제작자가 PDB를 배포했다면, Crash Logger처럼 DLL CTD 심볼 정확도가 올라갑니다(우리도 동일 컨셉으로 “plugin 폴더/심캐시”에서 로드). ([Nexus Mods][1])

### 6.3.3 “원인 후보 랭킹” 알고리즘(핵심 개선 포인트)

단순히 “Top of stack” 하나만 말하면 정확도가 낮습니다. 아래처럼 **증거 점수화**를 합니다.

* 증거 종류(예시)

  1. **Faulting IP 모듈**(크래시)
  2. **여러 스레드에서 반복 등장하는 모듈**
  3. **WCT wait chain의 cycle 구성원 스레드가 속한 모듈**(행)
  4. Blackbox 상 사건 직전 “특정 기능 이벤트”(예: 특정 메뉴 열기 → 특정 DLL 훅 기능이 관여)
  5. VRAM 급증/스크립트 heartbeat 끊김 등 보조 지표(참고: System Logger가 VRAM/heartbeat 로깅 제공) ([Nexus Mods][12])

* 출력 포맷(예시)

  * **가능성 Top 5**
  * 각 항목에:

    * Confidence(0~100)
    * 근거: (스택 프레임/모듈 주소/Wait chain 구조/직전 이벤트)
    * 사용자 액션: “해당 DLL 버전 확인”, “특정 모드 비활성화 A/B 테스트”, “심볼 제공 요청” 등

---

## 7. 출력물(사용자에게 제공되는 파일)

1. `SkyrimDiag_Report_<timestamp>.md` (요약 리포트)
2. `SkyrimDiag_Blackbox_<timestamp>.jsonl` (또는 dump user stream에 내장)
3. `SkyrimDiag_WCT_<timestamp>.json` (행 발생 시)
4. `SkyrimDiag_<timestamp>.dmp` (크래시/행 시)

---

## 8. 설정(ini/yaml) 설계

### 8.1 SkyrimDiag.ini (게임 내부)

* BlackboxSeconds=120
* FlushMode=OnCrashOnly / Periodic
* HeartbeatIntervalMs=100
* CrashHookMode=Passive(continue search) / Off
* FeatureToggles:

  * LogMenus=1
  * LogCells=1
  * LogPapyrusHeartbeat=1
  * LogVRAM=0/1

### 8.2 Helper 설정

* HangThresholdInGameSec=10
* HangThresholdLoadingSec=60
* DumpType=Mini(Default) / Triage / Full
* IncludeKernelStacks=0/1 (ProcDump의 -mk에 해당하는 개념은 ProcDump 문서에 존재) ([Microsoft Learn][10])

> 개인정보/용량 이슈 때문에 “기본은 미니덤프”, “재현 어려우면 풀덤프”를 권장.
> 참고로 ProcDump 문서에서도 triage 덤프는 “민감정보 제거 시도는 하지만 보장되진 않는다”고 명시합니다. ([Microsoft Learn][10])

---

## 9. 안정성/성능 설계 원칙

1. **플러그인은 절대 무겁게 돌지 않는다**

   * 링버퍼 write는 O(1), 동적 할당 최소화
2. **헬퍼가 무거운 작업(덤프/WCT/심볼)을 맡는다**
3. DbgHelp 단일 스레드 제약 준수

   * `MiniDumpWriteDump`, `StackWalk64`, `SymFromAddr` 동시 호출 금지 ([Microsoft Learn][8])
4. 크래시 상황에서는 “최소 WinAPI만 호출”

   * 가능하면 shared memory 기록 + 이벤트 신호 정도로 끝

---

## 10. 테스트/검증 계획

### 10.1 단위 테스트(Analyzer/Helper)

* 링버퍼 무결성(오버랩/인덱스 wrap)
* JSON 파서/리포트 생성
* WCT 파서(노드 타입/사이클 검출)

### 10.2 통합 테스트(실게임)

* 인위적 hang(테스트용 SKSE 플러그인으로 deadlock 유발) → WCT가 cycle을 보고하는지
* 인위적 crash(access violation) → 덤프 생성 + blackbox 포함 확인
* SE/AE/VR 런타임별 로딩 확인

  * CommonLibSSE-NG 멀티 런타임 DLL 전략을 따른다. ([GitHub][4])

---

## 11. 배포 패키징(예시)

```
Data/
  SKSE/
    Plugins/
      SkyrimDiag.dll
      SkyrimDiag.ini
Tools/
  SkyrimDiagHelper.exe
  SkyrimDiagHelper.yaml
Docs/
  README.md
  Troubleshooting.md
```

* Nexus 배포 시 “외부 exe 포함” 정책/백신 오탐 등을 고려해, Helper를 “선택 설치”로 둘 수도 있음.

---

## 12. Codex CLI(바이브코딩) 활용 계획

Codex CLI는 “터미널에서 로컬로 실행되는 코딩 에이전트”로, 선택한 디렉터리에서 **코드를 읽고/수정하고/커맨드를 실행**할 수 있다고 공식 문서가 설명합니다. ([OpenAI 개발자 포털][15])
GitHub 저장소도 설치 방법(예: `npm i -g @openai/codex`, `brew install --cask codex`)을 명시합니다. ([GitHub][16])

### 12.1 Codex로 “가능한 부분”

* 프로젝트 스캐폴딩/템플릿 적용(HelloWorld → SkyrimDiag 골격)
* 링버퍼/공유메모리/JSON 스키마/리포트 생성기 같은 **순수 소프트웨어 엔지니어링 작업**
* CI 구성(빌드/테스트 자동화)

### 12.2 Codex로 “어려운 부분(사람이 설계 주도 필요)”

* Skyrim 엔진 내부 훅 포인트 선정(어디를 후킹할지)
* 런타임별 안정성/호환성 검증
* 크래시 상황에서의 “안전한” 예외 처리(최소 호출로 신호만 보내는 설계)

즉, **Codex CLI는 구현 속도를 올리는 도구**로는 매우 유효하지만, “진단 정확도를 결정하는 핵심(무엇을 어떤 비용으로 수집할지)”은 이 설계서처럼 사람이 먼저 구조를 잡는 게 안전합니다.

---

## 13. 1차 MVP 범위(가장 현실적인 최소 제품)

**MVP 목표:** “프리징 원인 추적 + 크래시 시 직전 타임라인 확보”부터 확실히

* (필수) Blackbox 링버퍼 + 세션 메타(플러그인/ DLL 목록)
* (필수) Heartbeat 기반 hang 감지
* (필수) Hang 시 WCT 캡처 ([Microsoft Learn][3])
* (권장) Hang 시 MiniDumpWriteDump로 덤프 생성(외부 프로세스) ([Microsoft Learn][8])
* (선택) 크래시 예외 훅(패시브) + 덤프 생성(기존 크래시 로거와 공존 모드)

---

원하면, 위 설계서를 기반으로 **(1) CMake/폴더 구조**, **(2) shared memory 링버퍼 구조체**, **(3) WCT 수집 코드 골격**, **(4) 덤프에 user stream으로 blackbox 넣는 코드 골격**까지 “바로 구현 시작 가능한 수준”으로 더 내려서(모듈별 인터페이스/함수 시그니처/에러 처리/로그 포맷까지) 이어서 작성해드릴게요.

[1]: https://www.nexusmods.com/skyrimspecialedition/mods/59818 "Crash Logger SSE AE VR - PDB support at Skyrim Special Edition Nexus - Mods and Community"
[2]: https://www.nexusmods.com/skyrimspecialedition/mods/21294 "https://www.nexusmods.com/skyrimspecialedition/mods/21294"
[3]: https://learn.microsoft.com/en-us/windows/win32/debug/wait-chain-traversal "Wait chain traversal - Win32 apps | Microsoft Learn"
[4]: https://github.com/CharmedBaryon/CommonLibSSE-NG "GitHub - CharmedBaryon/CommonLibSSE-NG: This is a reverse engineered library for Skyrim Special Edition and Skyrim VR."
[5]: https://skyrim.dev/skse/first-plugin "Your first SKSE plugin in C++ • Skyrim.dev"
[6]: https://www.nexusmods.com/skyrimspecialedition/mods/32444 "Address Library for SKSE Plugins at Skyrim Special Edition Nexus - Mods and Community"
[7]: https://learn.microsoft.com/en-us/windows/win32/debug/using-wct "Using WCT - Win32 apps | Microsoft Learn"
[8]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump "MiniDumpWriteDump function (minidumpapiset.h) - Win32 apps | Microsoft Learn"
[9]: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream_information "https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_user_stream_information"
[10]: https://learn.microsoft.com/en-us/sysinternals/downloads/procdump "ProcDump - Sysinternals | Microsoft Learn"
[11]: https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/user-mode-dump-files "User-mode Dump Files - Windows drivers | Microsoft Learn"
[12]: https://www.nexusmods.com/skyrimspecialedition/mods/167083 "Skyrim System Logger at Skyrim Special Edition Nexus - Mods and Community"
[13]: https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfromaddr "https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfromaddr"
[14]: https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-stackwalk64 "StackWalk64 function (dbghelp.h) - Win32 apps | Microsoft Learn"
[15]: https://developers.openai.com/codex/cli/ "https://developers.openai.com/codex/cli/"
[16]: https://github.com/openai/codex "https://github.com/openai/codex"
